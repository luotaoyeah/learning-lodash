const _ = require("lodash");

/*
 * 接收 多 个参数：'目标对象'，'来源对象'（多个）；
 * 将'来源对象'的属性合并到'目标对象'，并返回'目标对象'；
 * --------------------------------------------------
 */

/*
 * '目标对象'会被修改；
 * --------------------------------------------------
 */
console.log("----------: '目标对象'会被修改");
const foo = { x: 1 };
_.merge(foo, { y: 2 });
/* { x: 1, y: 2 } */
console.log(foo);

/*
 * 返回结果就是'目标对象'；
 * --------------------------------------------------
 */
console.log("----------: 返回结果就是'目标对象'");
const foo01 = { x: 1 };
/* true */
console.log(foo01 === _.merge(foo01, { y: 2 }));

/*
 * 可以合并数组；
 * --------------------------------------------------
 */
console.log("----------: 可以合并数组");
/* [ 'a', 'b', 3 ] */
console.log(_.merge([1, 2, 3], ["a", "b"]));

/*
 * 如果'来源对象'的属性值为 undefined，
 * 且'目标对象'中存在该属性，则该属性会被忽略；
 * --------------------------------------------------
 */
console.log("----------: 忽略 undefined");
/* { x: 3, y: undefined } */
console.log(_.merge({ x: 1 }, { x: 3, y: undefined }));
/* { x: 3, y: null } */
console.log(_.merge({ x: 1, y: null }, { x: 3, y: undefined }));

/*
 * 对于同名属性，
 * 后面对象的属性值会覆盖前面对象的属性值；
 * --------------------------------------------------
 */
console.log("----------: 覆盖同名属性");
/* { x: 3 } */
console.log(_.merge({ x: 1 }, { x: 2 }, { x: 3 }));

/*
 * 继承属性也会被合并；
 * 先合并自身属性，再合并继承属性；
 * --------------------------------------------------
 */
console.log("----------: 合并继承属性");
/* { z: 3, x: 1, y: 2 } */
console.log(_.merge({}, _.create({ x: 1, y: 2 }, { z: 3 })));

/*
 * 合并时复制的是属性的值，而不是引用（与 _.assign() 的区别）；
 * --------------------------------------------------
 */
console.log("----------: 复制值而非引用");
const foo02 = { x: { name: "tom" } };
console.log(foo02.x === _.merge({}, foo02, { y: 2 }).x);
console.log(foo02.x === _.assign({}, foo02, { y: 2 }).x);
